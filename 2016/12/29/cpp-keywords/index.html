<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++小知识," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="关键字(keyword)又称保留字，是整个语言范围内预先保留的标识符。每个C++关键字都有特殊的含义。经过预处理后，关键字从预处理记号(preprocessing-token)中区别出来，剩下的标识符作为记号(token)，用于声明对象、函数、类型、命名空间等。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++小知识之关键字">
<meta property="og:url" content="http://lxjdaydayup.cn/2016/12/29/cpp-keywords/index.html">
<meta property="og:site_name" content="MYSPACE">
<meta property="og:description" content="关键字(keyword)又称保留字，是整个语言范围内预先保留的标识符。每个C++关键字都有特殊的含义。经过预处理后，关键字从预处理记号(preprocessing-token)中区别出来，剩下的标识符作为记号(token)，用于声明对象、函数、类型、命名空间等。">
<meta property="og:updated_time" content="2017-01-02T15:17:55.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++小知识之关键字">
<meta name="twitter:description" content="关键字(keyword)又称保留字，是整个语言范围内预先保留的标识符。每个C++关键字都有特殊的含义。经过预处理后，关键字从预处理记号(preprocessing-token)中区别出来，剩下的标识符作为记号(token)，用于声明对象、函数、类型、命名空间等。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://lxjdaydayup.cn/2016/12/29/cpp-keywords/"/>





  <title> C++小知识之关键字 | MYSPACE </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">MYSPACE</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://lxjdaydayup.cn/2016/12/29/cpp-keywords/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="DayDayUp">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="MYSPACE">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="MYSPACE" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++小知识之关键字
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-29T00:00:00+08:00">
                2016-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/12/29/cpp-keywords/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/29/cpp-keywords/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>关键字(keyword)又称保留字，是整个语言范围内预先保留的标识符。每个C++关键字都有特殊的含义。经过预处理后，关键字从预处理记号(preprocessing-token)中区别出来，剩下的标识符作为记号(token)，用于声明对象、函数、类型、命名空间等。</p>
<a id="more"></a>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了。</p>
<p>const只是在<code>编译期的保护</code>，编译期会检查const变量有没有被修改，如果有代码尝试修改一个const变量，编译器就会报错。但是由于const修饰的既然是变量，就有存储空间，我们可以通过地址修改空间里的值，这样还是可以改变的，也就是说const在一定程度上在编译期间使该变量变成了一个常量，然而它并没有实现保证该变量在运行期间内存中的值不被修改。</p>
<p>更多特点如下：</p>
<ol>
<li>const 的引用，对常量的引用不能用作修改它绑定的对象，但是由于对象本身可能是非常量，所以允许通过其他途径改变值。</li>
<li>对指针来说，可以指定指针本身为常量（const pointer, <code>常量指针</code>），也可以指定指针所指的对象为常量（pointer to const, <code>指向常量的指针</code>），或二者同时指定为const；</li>
<li>在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</li>
<li>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”（返回值是引用类型时，是可以作为左值使用的，一般用于操作符重载）。</li>
<li>对于类的成员函数，可以用const关键字来说明这个函数是 “只读(read-only)”函数，不会修改任何数据成员。为了声明一个const成员函数，把const关键字放在函数括号的后面。</li>
</ol>
<p>const 可以分为 <code>顶层const</code> 和 <code>底层const</code>，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类指针等。底层 const 则与指针或者引用等复合类型的基本类型部分有关。比较特别的是，指针既可以是顶层 const 又可以是底层 const。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;  <span class="comment">// 不能改变 ci 的值，是顶层 const;</span></div><div class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p1 = &amp;i; <span class="comment">// 不能改变 p1 的值，是顶层 const;</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;<span class="comment">// 允许改变 p2 的值，是底层 const;</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2;<span class="comment">// 前一个const底层，后一个顶层</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;  <span class="comment">// 用于声明引用的都是 底层 const</span></div></pre></td></tr></table></figure>
<p>在执行对象的拷贝动作时，常量是顶层const 时不受影响。拷贝执行操作并不会改变被拷贝对象的值，因此拷入和拷出的对象是否是常量都没什么影响。另一方面，<strong>底层 const 的限制不能忽视</strong>，当执行拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般来说，<strong>非常量可以转换为常量</strong>，反之则不行，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> tmp = <span class="number">88</span>;           <span class="comment">// 顶层 const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pp = &amp;tmp;  <span class="comment">// 底层const</span></div><div class="line"><span class="comment">// int *p = pp;         // pp 包含底层 const 的定义, 而 p 没有</span></div></pre></td></tr></table></figure>
<p>上面例子中如果允许<code>*pp = p3</code>，那么就可以通过 p 改变 pp 所指对象的值，这样 pp 就失去了底层 const 的约束。</p>
<p>不能为非常量引用绑定字面值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// int &amp;h = 42;        // Error, 不能为非常量引用绑定字面值</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;j = <span class="number">42</span>;     <span class="comment">// 正确: 可以为常量引用绑定字面值</span></div></pre></td></tr></table></figure>
<p><a href="http://blog.csdn.net/eric_jo/article/details/4138548" target="_blank" rel="external">关于C++ const 的全面总结</a>  </p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>《C和指针》中说static有两层含义：<code>指明存储属性；改变链接属性</code>。（1）全局变量（包括函数）加上static关键字后，链接属性变为internal，也就是将他们限定在了本作用域内；（2）局部变量加上static关键字后，存储属性变为静态存储，不存储在栈区，下一次将保持上一次的尾值。</p>
<p>C 面向过程程序设计中的static：</p>
<ol>
<li>静态局部变量。在函数体内，一个被声明为静态的变量在这一函数被调用过程中维持上一次的值不变，即只初始化一次（该变量存放在.bss 或者 .data 区，而不是栈区）。</li>
<li>静态全局变量。在模块内（但在函数体外），一个被声明为静态的变量可以被模块内函数访问，但不能被模块外访问。（注：模块可以理解为文件）。这样其它文件中可以定义相同名字的变量，不会发生冲突。</li>
<li>静态全局函数。在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。</li>
</ol>
<p>关于静态局部变量的存放位置，下面是一个不错的解释：</p>
<blockquote>
<p>Where your statics go depends on if they are 0 initialized or not. 0 initialized static data goes in .BSS (Block Started by Symbol), non 0 initialized data goes in .DATA </p>
</blockquote>
<p>关于静态全局变量和静态全局函数，下面是不错的解释：</p>
<blockquote>
<p>The whole and entire purpose of static is to declare that a variable is private to the source file that it is declared in. Thus, it is doing precisely its job in preventing a connection from an extern.  It is not visible to externs in other files, and you can have many different files that all declare static TYPE blah;, and they are all different.</p>
</blockquote>
<p>简单来说，对于static 的全局变量，它对链接器不可以见，所以这个变量只能在当前文件中使用。下面是一个简单的例子，分别在两个文件里面都定义了全局变量num，结果会导致重复定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ cat test_1.cpp</div><div class="line">int num = 5;</div><div class="line">$ cat test_2.cpp</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int num = 2;</div><div class="line"></div><div class="line">int main(void) &#123;</div><div class="line">    printf(&quot;num = %d\n&quot;, num);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">$ g++ test_1.cpp test_2.cpp -o test_2.o</div><div class="line">duplicate symbol _num in: </div><div class="line">...</div><div class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</div></pre></td></tr></table></figure>
<p>将其中任意一个（当然，两个全部改也可以） num 改为 static 全局变量，则没有问题。</p>
<p>C++面向对象程序设计中的static：</p>
<ul>
<li>静态成员变量：在类中的static成员变量意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；</li>
<li>静态成员函数：在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量(当然，可以通过传递一个对象来访问其成员)。</li>
</ul>
<p>在类成员的声明之前加上关键字 static 使得成员与类本身直接相关，而不是与类的各个对象保持关联。和其他成员一样，静态成员可以是 public 或 private 的，静态数据成员的类型可以是常量、引用、指针、类类型等。类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。</p>
<p><a href="https://yq.aliyun.com/articles/47641" target="_blank" rel="external">C/C++中的static关键字的总结</a>  </p>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>简单来说，extern可以置于变量或者函数前，以标示变量或者函数的定义在别的地方。</p>
<p>extern 可以用于<code>提前引用声明</code>：如果全局变量不在文件的开头定义，其生命周期只限于定义处到文件结尾。如果在变量定义之前的函数想引用该全局变量，则应该在引用之前用关键字extern对该变量作外部变量声明，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">extern int global;</div><div class="line">void show()&#123;</div><div class="line">    cout &lt;&lt; global &lt;&lt; &quot;\n&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int global = 10;</div><div class="line">int main()&#123;</div><div class="line">    show();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个更加一般和常见的用法是在多文件的程序中声明外部变量。如果一个程序包含两个文件，在两个文件中都要用到同一个外部变量num，不能在两个文件中各自定义一个外部变量num（变量只能被定义一次）。正确的做法是：在任一个文件中定义外部变量num，而在另一文件中用extern对num作外部变量声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ cat test_1.cpp</div><div class="line">int num = 5;</div><div class="line">$ cat test_2.cpp</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">extern int num;</div><div class="line"></div><div class="line">int main(void) &#123;</div><div class="line">    printf(&quot;num = %d\n&quot;, num);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">$ g++ test_1.cpp test_2.cpp -o test_2.o</div><div class="line">$ ./test_2.o</div><div class="line">num = 5</div></pre></td></tr></table></figure>
<p>背后的工作机制如下：编译系统在遇到 extern int num 时，了解到num是一个在别处定义的全局变量，它先在本文件中找全局变量num，如果有，则将其作用域扩展到本行开始；如果本文件中无此全局变量，则在程序链接时从其他文件中找全局变量num，如果有，则把在另一文件中定义的外部变量num的作用域扩展到本文件，然后在本文件中可以合法地引用该外部变量num。</p>
<p>在大型项目中，如果有许多个文件要用到共同的全局变量可以将其放置在一个专门的头文件中，然后在其中一个源文件定义变量，在其他的源文件中使用该变量。</p>
<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><p><code>函数名修饰机制</code></p>
<p>作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在symbol库中的名字与C语言的不同，假设某个函数的原型为：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void foo(int x, int y);</div></pre></td></tr></table></figure>
<p>该函数被C编译器编译后在symbol库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。_foo_int_int这样的名字包含了函数名和函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。   </p>
<p>为了实现C和C++的混合编程，C++提供了C连接交换指定符号<code>extern &quot;C&quot;</code>来解决名字匹配问题，函数声明前加上extern “C”后，则编译器就会按照C语言的方式将该函数编译为_foo，这样C语言中就可以调用C++的函数了。</p>
<p>extern “C”用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot;&#123;</div><div class="line">    int func(int);</div><div class="line">    int var;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++编译器会将在extern “C” 的大括号内部的代码当作C语言代码处理。所以很明显，上面的代码中，C++的名称修饰机制将不会起作用。它声明了一个C的函数func，定义了一个整形全局变量var。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示<strong>编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问</strong>。</p>
<p>volatile 指出变量是随时可能发生变化的，每次使用的时候必须从它所在的内存地址中读取，即使它前面的指令刚刚从该处读取过数据，而且读取的数据立刻被保存。而优化做法是，由于编译器发现两次读数据之间程序没有对变量进行过操作，它会自动使用上次读的数据。这样一来，如果是一个寄存器变量或者一个<code>端口数据</code>就会出错（它们的值由程序直接控制之外的过程控制），所以说volatile可以保证对特殊地址的稳定访问。</p>
<p>volatile 关键字不能保证全局变量多线程安全，因为 volatile 仅仅是告诫 compiler 不要对这个变量作优化，每次都要从 memory 取数值，而不是从register。</p>
<p><a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/06/24/1764231.html" target="_blank" rel="external">详解C中volatile关键字</a>   </p>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>内联机制用于优化规模较小、流程直接、频繁调用的函数，因为调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用包括：调用前保存寄存器并在返回时恢复，可能需要拷贝实参等。</p>
<p>inline函数背后的整体观念就是，将对此函数的每一个调用都以函数本体替换之。这通常是在编译时期完成的，但是需要注意的是<strong>inline只是对编译器发出的一个请求，编译器可以选择忽略这个请求</strong>。inline 可以是显式，也可以隐式，class 内部定义的函数被隐式的声明为 inline 。</p>
<p>inline函数可以调用又不至于导致函数调用的开销，但是仍有一些弊端。比如导致代码膨胀，进而造成额外的换页行为，降低指令高速缓存装置的命中率，以及伴随而来的效率损失。</p>
<p>此外，有时候编译器虽然愿意 inlining 某个函数，但还可能为该函数生成一个函数本体。比如如果程序要取某个 inline 函数的地址，编译器必须为此函数生成一个本体，比如虚函数和递归函数。</p>
<p><strong>内联函数的定义最好是放在头文件中</strong>，这样每一个包含该头文件的源文件均可以在编译器将调用该内联函数的代码展开。如果仅仅在头文件中声明内联函数，而在一个源文件中定义该函数，那么只有定义它的那个源文件可以在编译器展开内联函数。（这和模版类，函数模版的定义放在头文件中是基于同样的原理。）  </p>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>C++ 中，可以给一个合法的类型起一个<code>别名</code>，用以下句子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef existing_type new_type_name;</div></pre></td></tr></table></figure>
<p>其中 existing_type 可以是简单的基本类型，也可以是混合类型（比如 int *[]），new_type_name 是这个类型的一个标识符。如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typedef unsigned int WORD;</div><div class="line">typedef char * pChar;</div><div class="line">typedef char field [50];   // 合法的</div></pre></td></tr></table></figure>
<p>c++ 11 中也可以使用关键字 using 来进行类型别名的声明，上面类型别名也可用下面语句来进行声明（它们在语义上是对等的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">using WORD = unsigned int;</div><div class="line">using pChar = char *;</div><div class="line">using field = char [50];</div></pre></td></tr></table></figure>
<p>当定义一个函数指针时，typedef 用法稍微不同，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// pFun 为函数 int(int, char * ) 的指针</div><div class="line">typedef int (* pFun )(int, char* );</div><div class="line">using pFun = int(*)(int, char *);</div></pre></td></tr></table></figure>
<p>此外，要注意 typedef 并不同于 define 那样做简单的文本替换，而是<strong>类型别名</strong>，看下面的两个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef int *pt;    	  </div><div class="line">const pt a;     // a 是常量指针(pt是指针，前面加 const，说明是const pointer)</div><div class="line">int * const a;  // 等同于上一句  </div><div class="line">pt c, d;        // cd 都是 int * 类型的</div></pre></td></tr></table></figure>
<p><a href="http://niehan.blog.techweb.com.cn/archives/325.html" target="_blank" rel="external">揭秘 typedef四用途与两陷阱</a><br><a href="http://blog.csdn.net/gaohuaid/article/details/16829599" target="_blank" rel="external">typedef 用法总结</a>  </p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>一般情况下，变量的值是存放在内存中的。当程序中用到哪一个变量的值时，由控制器发出指令将内存中该变量的值送到CPU中的运算器。经过运算器进行运算，如果需要存储，再从运算器将数据送到内存存放。</p>
<p>为提高执行效率，C++允许将局部变量的值放在CPU中的寄存器中，需要用时直接从寄存器取出参加运算，不必再到内存中去存取。这种变量叫做寄存器变量，用关键字register作声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int fac(int n)</div><div class="line">&#123;</div><div class="line">   register int i,f=1; //定义i和f是寄存器变量</div><div class="line">   for(i=1;i&lt;=n;i++) f=f*i;</div><div class="line">   return f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义f和i是存放在寄存器的局部变量，如果n的值大，则能节约许多执行时间。不过要注意在程序中<strong>定义寄存器变量对编译系统只是建议性(而不是强制性)的</strong>。此外，现在的优化编译系统能够识别使用频繁的变量，自动地将这些变量放在寄存器中。</p>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><blockquote>
<p>The <a href="http://en.cppreference.com/w/cpp/language/explicit" target="_blank" rel="external">explicit specifier</a> specifies that a constructor or <strong>conversion function</strong> (since C++11) doesn’t allow <strong>implicit conversions</strong> or <strong>copy-initialization</strong>. </p>
</blockquote>
<p>复制初始化（<a href="http://en.cppreference.com/w/cpp/language/copy_initialization" target="_blank" rel="external">copy initialization</a>）是指用一个对象来初始化另一个对象。主要分下面六种情况：</p>
<ul>
<li>T object = other;     用<code>=操作符</code>声明一个非引用对象。</li>
<li>T object = {other}; C++ 11 中的列表初始化。</li>
<li>f(other); 向函数按照值传递传参数。</li>
<li>return other; 函数返回一个值。</li>
<li>throw object; catch (T object); throw 或者 catch 一个意外值。</li>
<li>T array[N] = {other}; </li>
</ul>
<p>有时候在需要类型 T2 的地方，我们给了类型 T1，并且没有显式地进行类型转换。这时候可能就用到了<strong>隐式类型转换</strong>（<a href="http://en.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="external">Implicit conversions</a>），编译器在背后默默地将 T1 转换为 T2（编译器背着程序员做了太多的事情）。</p>
<p>关键字的使用详情可以参考下面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> A</div><div class="line">&#123;</div><div class="line">    A(<span class="keyword">int</span>) &#123; &#125;      <span class="comment">// converting constructor</span></div><div class="line">    A(<span class="keyword">int</span>, <span class="keyword">int</span>) &#123; &#125; <span class="comment">// converting constructor (C++11)</span></div><div class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> B</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    A a1 = <span class="number">1</span>;      <span class="comment">// OK: copy-initialization selects A::A(int)</span></div><div class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK: direct-initialization selects A::A(int)</span></div><div class="line">    A a3 &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK: direct-list-initialization selects A::A(int, int)</span></div><div class="line">    A a4 = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// OK: copy-list-initialization selects A::A(int, int)</span></div><div class="line">    A a5 = (A)<span class="number">1</span>;   <span class="comment">// OK: explicit cast performs static_cast</span></div><div class="line">    <span class="keyword">if</span> (a1) <span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// OK: A::operator bool()</span></div><div class="line">    <span class="keyword">bool</span> na1 = a1; <span class="comment">// OK: copy-initialization selects A::operator bool()</span></div><div class="line">    <span class="keyword">bool</span> na2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a1); <span class="comment">// OK: static_cast performs direct-initialization</span></div><div class="line"></div><div class="line"><span class="comment">//  B b1 = 1;      // error: copy-initialization does not consider B::B(int)</span></div><div class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK: direct-initialization selects B::B(int)</span></div><div class="line">    B b3 &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK: direct-list-initialization selects B::B(int, int)</span></div><div class="line"><span class="comment">//  B b4 = &#123;4, 5&#125;; // error: copy-list-initialization does not consider B::B(int,int)</span></div><div class="line">    B b5 = (B)<span class="number">1</span>;   <span class="comment">// OK: explicit cast performs static_cast</span></div><div class="line">    <span class="keyword">if</span> (b5) <span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// OK: B::operator bool()</span></div><div class="line"><span class="comment">//  bool nb1 = b2; // error: copy-initialization does not consider B::operator bool()</span></div><div class="line">    <span class="keyword">bool</span> nb2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b2); <span class="comment">// OK: static_cast performs direct-initialization</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>explicit</code></strong>关键字抑制构造函数的隐式转换</p>
<ul>
<li>关键字<code>explicit</code>只对一个实参的构造函数有效，而且只能在类内声明构造函数时使用，在类外定义时不应重复。当我们用<code>explicit</code>关键字声明构造函数时，它将只能以直接初始化的形式使用，而且编译器将不会在自动转换的过程中使用该构造函数。</li>
<li>尽管编译器不会将<code>explicit</code>的构造函数用于隐式转换过程，但我们可以使用显示强制转换，如<code>static_cast&lt;Class&gt;(int)</code></li>
</ul>
<p><strong><code>explicit</code></strong>显式的类型转换运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> SmallInt&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  	<span class="comment">//编译器不会自动执行这一类型的转换</span></div><div class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</div><div class="line">  	<span class="comment">//其他内容</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">SmallInt si = <span class="number">3</span>;	<span class="comment">//正确，SmallInt的构造函数不是显式的</span></div><div class="line">si + <span class="number">3</span>;			<span class="comment">//错误，此处需要隐式的类型转换，但类的运算符是显式的</span></div><div class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>;	<span class="comment">//正确，显式地请求类型转换</span></div></pre></td></tr></table></figure>
<ul>
<li>例外：如果表达式被用作条件，编译器会将显式的类型转换自动应用，适用范围有以下几个：</li>
</ul>
<ol>
<li><code>if</code>、<code>while</code>及<code>do</code>语句的条件部分</li>
<li><code>for</code>语句的条件表达式</li>
<li>逻辑非运算符<code>!</code>、逻辑或运算符<code>||</code>、逻辑与运算符<code>&amp;&amp;</code>的运算对象</li>
<li>条件运算符<code>?:</code>的条件表达式</li>
</ol>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>C++ 11 中引入了final关键字，用来阻止类的进一步派生和虚函数的进一步重载。</p>
<blockquote>
<p>Specifies that a virtual function cannot be overridden in a derived class or that a class cannot be inherited from.</p>
</blockquote>
<p>看一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Base</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> A : Base</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> final</span>; <span class="comment">// A::foo is final</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> final</span>; <span class="comment">// Error: non-virtual function cannot be final</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> B final : A <span class="comment">// struct B is final</span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// Error: foo cannot be overridden as it's final in A</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> C : B <span class="comment">// Error: B is final</span></div><div class="line">&#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>一个派生类可以覆盖在基类中声明的虚函数，这是面向对象设计的基础。然而这么简单的操作也会出错，关于覆盖虚函数的两个常见错误如下： </p>
<ul>
<li><code>无意中覆盖</code>：派生类不小心实现了一个和基类名字和参数列表相同的虚函数。</li>
<li><code>签名不匹配</code>：本来要覆盖基类的虚函数，结果导致产生了一个新的函数。</li>
</ul>
<p>使用 override 可以避免这两个问题。因为 override 明确告诉编译器该函数覆盖了基类中的虚函数，任何违反了这一语义的实现编译器都将显式地给出错误提示。</p>
<blockquote>
<p>In a member function declaration or definition, override ensures that the function is virtual and is overriding a virtual function from the base class. The program is ill-formed (a compile-time error is generated) if this is not true.</p>
</blockquote>
<p>看一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> A</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> B : A</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> override</span>; <span class="comment">// Error: B::foo does not override A::foo</span></div><div class="line">                               <span class="comment">// (signature mismatch)</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">// OK: B::foo overrides A::foo</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> override</span>; <span class="comment">// Error: A::bar is not virtual</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>编译器实现 override 的方法很简单，如下：</p>
<blockquote>
<p>The override special identifier means that the compiler will check the base class(es) to see if there is a virtual function with this exact signature. And if there is not, the compiler will error out.</p>
</blockquote>
<p>不过注意 override 和 final 一样，不是C++保留字：</p>
<blockquote>
<p>Note that neither override nor final are language keywords. They are technically identifiers; they only gain special meaning when used in those specific contexts. In any other location, they can be valid identifiers.</p>
</blockquote>
<h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h2><p>new和delete对堆中的内存进行申请和释放，而且这两个操作符是不能被重载的。要实现不同的内存分配行为，需要重载operator new，而不是new和delete。</p>
<p>看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class foo&#123;&#125;;</div><div class="line">foo* pfoo = new foo;</div></pre></td></tr></table></figure>
<p>这里的new实际上是执行如下3个过程：</p>
<ol>
<li>调用operator new分配内存；</li>
<li>调用构造函数生成类对象；</li>
<li>返回相应指针。</li>
</ol>
<p>operator new 就像 operator+ 一样，是可以重载的，但是不能在全局对原型为void operator new(size_t size)这个原型进行重载，一般只能在类中进行重载。</p>
<p>如果类中没有重载operator new，那么调用的就是全局的::operator new来完成堆的分配。同理，operator new[]、operator delete、operator delete[]也是可以重载的。</p>
<p>new 操作符分配内存需要在堆中查找足够大的剩余空间，这个操作速度是很慢的，而且有可能出现无法分配内存的异常（空间不够）。</p>
<blockquote>
<p><a href="https://github.com/xuelangZF/CS_Offer/tree/master/C%2B%2B" target="_blank" rel="external">原文</a></p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C-小知识/" rel="tag"># C++小知识</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/28/cpp-more/" rel="next" title="C++小知识之杂项">
                <i class="fa fa-chevron-left"></i> C++小知识之杂项
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/29/cpp-compiler/" rel="prev" title="C++小知识之编译器工作原理">
                C++小知识之编译器工作原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/12/29/cpp-keywords/"
     data-title="C++小知识之关键字"
     data-content=""
     data-url="http://lxjdaydayup.cn/2016/12/29/cpp-keywords/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/12/29/cpp-keywords/"
           data-title="C++小知识之关键字" data-url="http://lxjdaydayup.cn/2016/12/29/cpp-keywords/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="DayDayUp" />
          <p class="site-author-name" itemprop="name">DayDayUp</p>
          <p class="site-description motion-element" itemprop="description">知足者常乐，能忍者自安</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://github.com/xiaojiele" target="_blank" title="gitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  gitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:lxjdaydayup@outlook.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope-o"></i>
                  
                  Email
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.baidu.com/" title="Baidu" target="_blank">Baidu</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.duxieren.com/" title="Dushuren" target="_blank">Dushuren</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.zhihu.com/topic/19550228/top-answers" title="Zhihu" target="_blank">Zhihu</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#const"><span class="nav-number">1.</span> <span class="nav-text">const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">2.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extern"><span class="nav-number">3.</span> <span class="nav-text">extern</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extern-“C”"><span class="nav-number">4.</span> <span class="nav-text">extern “C”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-number">5.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inline"><span class="nav-number">6.</span> <span class="nav-text">inline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typedef"><span class="nav-number">7.</span> <span class="nav-text">typedef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#register"><span class="nav-number">8.</span> <span class="nav-text">register</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explicit"><span class="nav-number">9.</span> <span class="nav-text">explicit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-number">10.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#override"><span class="nav-number">11.</span> <span class="nav-text">override</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-操作符"><span class="nav-number">12.</span> <span class="nav-text">new 操作符</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DayDayUp</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"lxjdaydayup"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
